import 'package:cloud_firestore/cloud_firestore.dart';
import 'dart:math' as math;

class UserModel {
  final String uid;
  final String email;
  final String username;
  final String? avatarUrl;
  final DateTime createdAt;
  final DateTime lastActive;
  final RatingData rating;
  final TransactionStats transactionStats;
  final UserPreferences preferences;
  final LocationData? location;
  final bool isAdmin;
  final bool isBanned;
  
  // 新增：推播訂閱相關
  final List<String> subscribedKeywords;     // 訂閱的關鍵字列表
  final List<String> notifiedItemIds;       // 已推播過的物品ID（防重複）
  final NotificationSettings notificationSettings; // 通知偏好設定

  UserModel({
    required this.uid,
    required this.email,
    required this.username,
    this.avatarUrl,
    required this.createdAt,
    required this.lastActive,
    required this.rating,
    required this.transactionStats,
    required this.preferences,
    this.location,
    this.isAdmin = false,
    this.isBanned = false,
    // 新增屬性的預設值
    this.subscribedKeywords = const [],
    this.notifiedItemIds = const [],
    NotificationSettings? notificationSettings,
  }) : notificationSettings = notificationSettings ?? NotificationSettings();

  factory UserModel.fromFirestore(DocumentSnapshot doc) {
    Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
    
    return UserModel(
      uid: doc.id,
      email: data['email'] ?? '',
      username: data['username'] ?? '',
      avatarUrl: data['avatarUrl'],
      createdAt: (data['createdAt'] as Timestamp).toDate(),
      lastActive: (data['lastActive'] as Timestamp).toDate(),
      rating: RatingData.fromMap(data['rating'] ?? {}),
      transactionStats: TransactionStats.fromMap(data['transactionStats'] ?? {}),
      preferences: UserPreferences.fromMap(data['preferences'] ?? {}),
      location: data['location'] != null 
          ? LocationData.fromMap(data['location']) 
          : null,
      isAdmin: data['isAdmin'] ?? false,
      isBanned: data['isBanned'] ?? false,
      // 新增屬性的解析
      subscribedKeywords: List<String>.from(data['subscribedKeywords'] ?? []),
      notifiedItemIds: List<String>.from(data['notifiedItemIds'] ?? []),
      notificationSettings: NotificationSettings.fromMap(data['notificationSettings'] ?? {}),
    );
  }

  Map<String, dynamic> toFirestore() {
    return {
      'email': email,
      'username': username,
      'avatarUrl': avatarUrl,
      'createdAt': Timestamp.fromDate(createdAt),
      'lastActive': Timestamp.fromDate(lastActive),
      'rating': rating.toMap(),
      'transactionStats': transactionStats.toMap(),
      'preferences': preferences.toMap(),
      'location': location?.toMap(),
      'isAdmin': isAdmin,
      'isBanned': isBanned,
      // 新增屬性的序列化
      'subscribedKeywords': subscribedKeywords,
      'notifiedItemIds': notifiedItemIds,
      'notificationSettings': notificationSettings.toMap(),
    };
  }

  // 新增：關鍵字管理方法
  UserModel addKeyword(String keyword) {
    final newKeywords = List<String>.from(subscribedKeywords);
    final cleanKeyword = keyword.trim().toLowerCase();
    if (cleanKeyword.isNotEmpty && !newKeywords.contains(cleanKeyword)) {
      newKeywords.add(cleanKeyword);
    }
    return copyWith(subscribedKeywords: newKeywords);
  }

  UserModel removeKeyword(String keyword) {
    final newKeywords = List<String>.from(subscribedKeywords);
    newKeywords.remove(keyword.toLowerCase());
    return copyWith(subscribedKeywords: newKeywords);
  }

  UserModel updateKeywords(List<String> keywords) {
    final cleanKeywords = keywords
        .map((k) => k.trim().toLowerCase())
        .where((k) => k.isNotEmpty)
        .toSet()
        .toList();
    return copyWith(subscribedKeywords: cleanKeywords);
  }

  // 新增：檢查是否應該接收特定物品的通知
  bool shouldReceiveNotification(String itemId, double itemLat, double itemLng) {
    // 檢查基本通知設定
    if (!preferences.enableNotifications || !notificationSettings.enabled) {
      return false;
    }
    
    // 檢查是否已經通知過這個物品
    if (notifiedItemIds.contains(itemId)) {
      return false;
    }
    
    // 檢查是否在勿擾時間
    if (notificationSettings.isQuietHours()) {
      return false;
    }
    
    // 檢查距離是否在範圍內
    if (location != null) {
      double distance = _calculateDistance(
        location!.latitude,
        location!.longitude,
        itemLat,
        itemLng,
      );
      if (distance > notificationSettings.notificationRadius) {
        return false;
      }
    }
    
    return true;
  }

  // 新增：檢查物品是否符合訂閱關鍵字
  bool itemMatchesKeywords(String itemTag, String itemDescription) {
    if (subscribedKeywords.isEmpty) return false;
    
    final itemText = '$itemTag $itemDescription'.toLowerCase();
    return subscribedKeywords.any((keyword) => itemText.contains(keyword));
  }

  // 新增：獲取符合的關鍵字
  List<String> getMatchedKeywords(String itemTag, String itemDescription) {
    if (subscribedKeywords.isEmpty) return [];
    
    final itemText = '$itemTag $itemDescription'.toLowerCase();
    return subscribedKeywords
        .where((keyword) => itemText.contains(keyword))
        .toList();
  }

  // 新增：標記物品已通知
  UserModel markItemNotified(String itemId) {
    final newNotifiedIds = List<String>.from(notifiedItemIds);
    if (!newNotifiedIds.contains(itemId)) {
      newNotifiedIds.add(itemId);
      
      // 保持列表不要太長，只保留最近500筆
      if (newNotifiedIds.length > 500) {
        newNotifiedIds.removeRange(0, newNotifiedIds.length - 500);
      }
    }
    return copyWith(notifiedItemIds: newNotifiedIds);
  }

  // 新增：更新位置
  UserModel updateLocation(double latitude, double longitude, {String? address}) {
    final newLocation = LocationData(
      latitude: latitude,
      longitude: longitude,
      address: address ?? location?.address,
      lastUpdated: DateTime.now(),
    );
    return copyWith(location: newLocation);
  }

  // 私有方法：計算兩點間距離（公里）
  double _calculateDistance(double lat1, double lon1, double lat2, double lon2) {
    const double earthRadius = 6371;
    
    double dLat = _toRadians(lat2 - lat1);
    double dLon = _toRadians(lon2 - lon1);
    
    double a = math.sin(dLat / 2) * math.sin(dLat / 2) +
        math.cos(_toRadians(lat1)) * math.cos(_toRadians(lat2)) *
        math.sin(dLon / 2) * math.sin(dLon / 2);
    
    double c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a));
    
    return earthRadius * c;
  }

  double _toRadians(double degree) {
    return degree * (math.pi / 180);
  }

  // 新增：copyWith 方法
  UserModel copyWith({
    String? uid,
    String? email,
    String? username,
    String? avatarUrl,
    DateTime? createdAt,
    DateTime? lastActive,
    RatingData? rating,
    TransactionStats? transactionStats,
    UserPreferences? preferences,
    LocationData? location,
    bool? isAdmin,
    bool? isBanned,
    List<String>? subscribedKeywords,
    List<String>? notifiedItemIds,
    NotificationSettings? notificationSettings,
  }) {
    return UserModel(
      uid: uid ?? this.uid,
      email: email ?? this.email,
      username: username ?? this.username,
      avatarUrl: avatarUrl ?? this.avatarUrl,
      createdAt: createdAt ?? this.createdAt,
      lastActive: lastActive ?? this.lastActive,
      rating: rating ?? this.rating,
      transactionStats: transactionStats ?? this.transactionStats,
      preferences: preferences ?? this.preferences,
      location: location ?? this.location,
      isAdmin: isAdmin ?? this.isAdmin,
      isBanned: isBanned ?? this.isBanned,
      subscribedKeywords: subscribedKeywords ?? this.subscribedKeywords,
      notifiedItemIds: notifiedItemIds ?? this.notifiedItemIds,
      notificationSettings: notificationSettings ?? this.notificationSettings,
    );
  }
}

// 新增：通知設定類別
class NotificationSettings {
  final bool enabled;                    // 是否啟用推播
  final int quietHoursStart;            // 勿擾時間開始（24小時制）
  final int quietHoursEnd;              // 勿擾時間結束（24小時制）
  final int maxNotificationsPerHour;    // 每小時最多通知次數
  final double notificationRadius;      // 接收通知的範圍（公里）
  final bool locationUpdateNotifications; // 位置變化時的通知

  NotificationSettings({
    this.enabled = true,
    this.quietHoursStart = 22,
    this.quietHoursEnd = 8,
    this.maxNotificationsPerHour = 3,
    this.notificationRadius = 2.0,
    this.locationUpdateNotifications = true,
  });

  factory NotificationSettings.fromMap(Map<String, dynamic> map) {
    return NotificationSettings(
      enabled: map['enabled'] ?? true,
      quietHoursStart: map['quietHoursStart'] ?? 22,
      quietHoursEnd: map['quietHoursEnd'] ?? 8,
      maxNotificationsPerHour: map['maxNotificationsPerHour'] ?? 3,
      notificationRadius: map['notificationRadius']?.toDouble() ?? 2.0,
      locationUpdateNotifications: map['locationUpdateNotifications'] ?? true,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'enabled': enabled,
      'quietHoursStart': quietHoursStart,
      'quietHoursEnd': quietHoursEnd,
      'maxNotificationsPerHour': maxNotificationsPerHour,
      'notificationRadius': notificationRadius,
      'locationUpdateNotifications': locationUpdateNotifications,
    };
  }

  // 檢查是否在勿擾時間
  bool isQuietHours() {
    if (!enabled) return true;
    
    final now = DateTime.now();
    final currentHour = now.hour;
    
    if (quietHoursStart <= quietHoursEnd) {
      // 同一天內的時間範圍（例如 8:00-22:00 是工作時間）
      return currentHour < quietHoursStart || currentHour >= quietHoursEnd;
    } else {
      // 跨天的時間範圍（例如 22:00-8:00 是休息時間）
      return currentHour >= quietHoursStart || currentHour < quietHoursEnd;
    }
  }

  NotificationSettings copyWith({
    bool? enabled,
    int? quietHoursStart,
    int? quietHoursEnd,
    int? maxNotificationsPerHour,
    double? notificationRadius,
    bool? locationUpdateNotifications,
  }) {
    return NotificationSettings(
      enabled: enabled ?? this.enabled,
      quietHoursStart: quietHoursStart ?? this.quietHoursStart,
      quietHoursEnd: quietHoursEnd ?? this.quietHoursEnd,
      maxNotificationsPerHour: maxNotificationsPerHour ?? this.maxNotificationsPerHour,
      notificationRadius: notificationRadius ?? this.notificationRadius,
      locationUpdateNotifications: locationUpdateNotifications ?? this.locationUpdateNotifications,
    );
  }
}

class RatingData {
  final double averageRating;
  final int totalRatings;
  final int positiveCount;
  final int negativeCount;

  RatingData({
    this.averageRating = 0.0,
    this.totalRatings = 0,
    this.positiveCount = 0,
    this.negativeCount = 0,
  });

  factory RatingData.fromMap(Map<String, dynamic> map) {
    return RatingData(
      averageRating: map['averageRating']?.toDouble() ?? 0.0,
      totalRatings: map['totalRatings'] ?? 0,
      positiveCount: map['positiveCount'] ?? 0,
      negativeCount: map['negativeCount'] ?? 0,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'averageRating': averageRating,
      'totalRatings': totalRatings,
      'positiveCount': positiveCount,
      'negativeCount': negativeCount,
    };
  }
}

class TransactionStats {
  final DateTime joinDate;
  final int totalItemsShared;
  final int totalItemsReceived;
  final int completedTransactions;
  final int totalGiven;
  final int totalReceived;
  final int totalPosted;
  final int recentReceivedCount;
  final DateTime? lastTransactionDate;

  TransactionStats({
    required this.joinDate,
    this.totalItemsShared = 0,
    this.totalItemsReceived = 0,
    this.completedTransactions = 0,
    this.totalGiven = 0,
    this.totalReceived = 0,
    this.totalPosted = 0,
    this.recentReceivedCount = 0,
    this.lastTransactionDate,
  });

  factory TransactionStats.fromMap(Map<String, dynamic> map) {
    return TransactionStats(
      joinDate: map['joinDate'] != null 
          ? (map['joinDate'] as Timestamp).toDate()
          : DateTime.now(),
      totalItemsShared: map['totalItemsShared'] ?? 0,
      totalItemsReceived: map['totalItemsReceived'] ?? 0,
      completedTransactions: map['completedTransactions'] ?? 0,
      totalGiven: map['totalGiven'] ?? 0,
      totalReceived: map['totalReceived'] ?? 0,
      totalPosted: map['totalPosted'] ?? 0,
      recentReceivedCount: map['recentReceivedCount'] ?? 0,
      lastTransactionDate: map['lastTransactionDate'] != null
          ? (map['lastTransactionDate'] as Timestamp).toDate()
          : null,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'joinDate': Timestamp.fromDate(joinDate),
      'totalItemsShared': totalItemsShared,
      'totalItemsReceived': totalItemsReceived,
      'completedTransactions': completedTransactions,
      'totalGiven': totalGiven,
      'totalReceived': totalReceived,
      'totalPosted': totalPosted,
      'recentReceivedCount': recentReceivedCount,
      'lastTransactionDate': lastTransactionDate != null
          ? Timestamp.fromDate(lastTransactionDate!)
          : null,
    };
  }
}

class UserPreferences {
  final double searchRadius;
  final bool enableNotifications;
  final bool enableLocationSharing;
  final List<String> favoriteCategories;
  final int maxDailyReceive;
  final bool publicProfile;

  UserPreferences({
    this.searchRadius = 2.0,
    this.enableNotifications = true,
    this.enableLocationSharing = true,
    this.favoriteCategories = const [],
    this.maxDailyReceive = 2,
    this.publicProfile = true,
  });

  factory UserPreferences.fromMap(Map<String, dynamic> map) {
    return UserPreferences(
      searchRadius: map['searchRadius']?.toDouble() ?? 2.0,
      enableNotifications: map['enableNotifications'] ?? true,
      enableLocationSharing: map['enableLocationSharing'] ?? true,
      favoriteCategories: List<String>.from(map['favoriteCategories'] ?? []),
      maxDailyReceive: map['maxDailyReceive'] ?? 2,
      publicProfile: map['publicProfile'] ?? true,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'searchRadius': searchRadius,
      'enableNotifications': enableNotifications,
      'enableLocationSharing': enableLocationSharing,
      'favoriteCategories': favoriteCategories,
      'maxDailyReceive': maxDailyReceive,
      'publicProfile': publicProfile,
    };
  }
}

class LocationData {
  final double latitude;
  final double longitude;
  final String? address;
  final DateTime? lastUpdated;

  LocationData({
    required this.latitude,
    required this.longitude,
    this.address,
    this.lastUpdated,
  });

  factory LocationData.fromMap(Map<String, dynamic> map) {
    return LocationData(
      latitude: map['latitude']?.toDouble() ?? 0.0,
      longitude: map['longitude']?.toDouble() ?? 0.0,
      address: map['address'],
      lastUpdated: map['lastUpdated'] != null 
          ? (map['lastUpdated'] as Timestamp).toDate()
          : null,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'latitude': latitude,
      'longitude': longitude,
      'address': address,
      'lastUpdated': lastUpdated != null 
          ? Timestamp.fromDate(lastUpdated!)
          : null,
    };
  }
}
