import 'dart:io';
import 'dart:math';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:geoflutterfire2/geoflutterfire2.dart';
import 'package:uuid/uuid.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../models/item_model.dart';
import '../models/user_model.dart';
import '../models/notification_model.dart';

class ItemService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseStorage _storage = FirebaseStorage.instance;
  final GeoFlutterFire _geo = GeoFlutterFire();
  static const String _transactionRecordsCollection = 'transaction_records';

  // ç²å–ç•¶å‰ç”¨æˆ¶ID
  String? get _currentUserId => FirebaseAuth.instance.currentUser?.uid;

  Future<String> addItem({
    required String ownerId,
    required String description,
    required String tag,
    required List<File> imageFiles,
    required double latitude,
    required double longitude,
    String? address,
  }) async {
    try {
      print('ItemService: é–‹å§‹ä¸Šæž¶æµç¨‹');
      String itemId = Uuid().v4();
      print('ItemService: ç”Ÿæˆ itemId=$itemId');
      
      List<String> imageUrls = await _uploadImages(itemId, imageFiles);
      
      LocationData originalLocation = LocationData(
        latitude: latitude,
        longitude: longitude,
        address: address,
      );
      
      LocationData fuzzyLocation = _addRandomOffset(originalLocation);
      
      GeoFirePoint geoPoint = _geo.point(
        latitude: originalLocation.latitude,
        longitude: originalLocation.longitude,
      );
      
      ItemModel item = ItemModel(
        id: itemId,
        ownerId: ownerId,
        description: description,
        tag: tag,
        imageUrls: imageUrls,
        location: fuzzyLocation,
        originalLocation: originalLocation,
        createdAt: DateTime.now(),
        status: ItemStatus.available, // ä½¿ç”¨æ–°çš„ç‹€æ…‹ç³»çµ±
        geoHash: geoPoint.hash,
      );

      Map<String, dynamic> itemData = item.toFirestore();
      itemData['g'] = geoPoint.data;

      await _firestore
          .collection('items')
          .doc(itemId)
          .set(itemData);

      print('ItemService: ç‰©å“ä¸Šæž¶æˆåŠŸï¼Œé–‹å§‹æª¢æŸ¥æŽ¨æ’­');
      
      // æ–°å¢žï¼šç‰©å“ä¸Šæž¶æˆåŠŸå¾Œæª¢æŸ¥æŽ¨æ’­
      await _checkAndNotifySubscribers(
        itemId: itemId,
        tag: tag,
        description: description,
        latitude: originalLocation.latitude,
        longitude: originalLocation.longitude,
        imageUrl: imageUrls.isNotEmpty ? imageUrls.first : null,
        ownerId: ownerId,
      );

      return itemId;
    } catch (e) {
      print('ItemService: ç™¼ç”ŸéŒ¯èª¤=$e');
      throw e;
    }
  }

  // æ–°å¢žï¼šæª¢æŸ¥ä¸¦é€šçŸ¥è¨‚é–±ç”¨æˆ¶
  Future<void> _checkAndNotifySubscribers({
    required String itemId,
    required String tag,
    required String description,
    required double latitude,
    required double longitude,
    String? imageUrl,
    required String ownerId,
  }) async {
    try {
      print('ItemService: é–‹å§‹æª¢æŸ¥æŽ¨æ’­è¨‚é–±ï¼Œç‰©å“: $tag');

      // 1. æŸ¥è©¢é™„è¿‘çš„ç”¨æˆ¶ï¼ˆ2kmç¯„åœå…§ï¼‰
      List<UserModel> nearbyUsers = await _getNearbyUsers(
        latitude, 
        longitude, 
        radiusKm: 2.0
      );

      print('ItemService: æ‰¾åˆ° ${nearbyUsers.length} å€‹é™„è¿‘ç”¨æˆ¶');

      // 2. æª¢æŸ¥æ¯å€‹ç”¨æˆ¶çš„è¨‚é–±æ¢ä»¶ä¸¦ç™¼é€é€šçŸ¥
      int notificationCount = 0;
      List<Future<void>> notificationTasks = [];

      for (UserModel user in nearbyUsers) {
        // æŽ’é™¤ç‰©å“æ“æœ‰è€…
        if (user.uid == ownerId) continue;

        // æª¢æŸ¥æ˜¯å¦ç¬¦åˆé€šçŸ¥æ¢ä»¶
        if (_shouldNotifyUser(user, itemId, tag, description, latitude, longitude)) {
          // æ‰¾å‡ºç¬¦åˆçš„é—œéµå­—
          List<String> matchedKeywords = user.getMatchedKeywords(tag, description);
          
          // è¨ˆç®—è·é›¢
          double distance = _calculateDistance(
            user.location?.latitude ?? latitude,
            user.location?.longitude ?? longitude,
            latitude,
            longitude,
          );

          // å‰µå»ºä¸¦ç™¼é€é€šçŸ¥
          notificationTasks.add(_sendNotificationToUser(
            user: user,
            itemId: itemId,
            itemTitle: tag,
            itemDescription: description,
            matchedKeywords: matchedKeywords,
            distance: distance,
            imageUrl: imageUrl,
          ));
          
          notificationCount++;
        }
      }

      // 3. ç­‰å¾…æ‰€æœ‰é€šçŸ¥ç™¼é€å®Œæˆ
      if (notificationTasks.isNotEmpty) {
        await Future.wait(notificationTasks);
      }
      
      print('ItemService: æŽ¨æ’­æª¢æŸ¥å®Œæˆï¼Œç™¼é€äº† $notificationCount å€‹é€šçŸ¥');

    } catch (e) {
      print('ItemService: æŽ¨æ’­æª¢æŸ¥å¤±æ•—: $e');
      // æŽ¨æ’­å¤±æ•—ä¸æ‡‰è©²å½±éŸ¿ç‰©å“ä¸Šæž¶ï¼Œæ‰€ä»¥ä¸ rethrow
    }
  }

  // æ–°å¢žï¼šæŸ¥è©¢é™„è¿‘ç”¨æˆ¶
  Future<List<UserModel>> _getNearbyUsers(double centerLat, double centerLng, {double radiusKm = 2.0}) async {
    try {
      // è¨ˆç®—æŸ¥è©¢é‚Šç•Œ
      double latRange = radiusKm / 111.0; // å¤§ç´„1åº¦ = 111km
      double lngRange = radiusKm / (111.0 * cos(centerLat * pi / 180));

      double minLat = centerLat - latRange;
      double maxLat = centerLat + latRange;
      double minLng = centerLng - lngRange;
      double maxLng = centerLng + lngRange;

      // æŸ¥è©¢æœ‰ä½ç½®ä¸”å•Ÿç”¨é€šçŸ¥çš„ç”¨æˆ¶
      QuerySnapshot querySnapshot = await _firestore
          .collection('users')
          .where('preferences.enableNotifications', isEqualTo: true)
          .get();

      List<UserModel> nearbyUsers = [];
      
      for (DocumentSnapshot doc in querySnapshot.docs) {
        try {
          UserModel user = UserModel.fromFirestore(doc);
          
          // æª¢æŸ¥æ˜¯å¦æœ‰ä½ç½®è³‡è¨Š
          if (user.location == null) continue;
          
          // æª¢æŸ¥æ˜¯å¦åœ¨ç¯„åœå…§
          if (user.location!.latitude >= minLat && user.location!.latitude <= maxLat &&
              user.location!.longitude >= minLng && user.location!.longitude <= maxLng) {
            
            // ç²¾ç¢ºè·é›¢æª¢æŸ¥
            double distance = _calculateDistance(
              centerLat, centerLng,
              user.location!.latitude, user.location!.longitude,
            );
            
            if (distance <= radiusKm) {
              nearbyUsers.add(user);
            }
          }
        } catch (e) {
          print('ItemService: è§£æžç”¨æˆ¶è³‡æ–™å¤±æ•—: $e');
          continue;
        }
      }

      return nearbyUsers;
    } catch (e) {
      print('ItemService: æŸ¥è©¢é™„è¿‘ç”¨æˆ¶å¤±æ•—: $e');
      return [];
    }
  }

  // æ–°å¢žï¼šæª¢æŸ¥æ˜¯å¦æ‡‰è©²é€šçŸ¥ç”¨æˆ¶
  bool _shouldNotifyUser(UserModel user, String itemId, String tag, String description, double itemLat, double itemLng) {
    // åŸºæœ¬æ¢ä»¶æª¢æŸ¥
    if (!user.shouldReceiveNotification(itemId, itemLat, itemLng)) {
      return false;
    }

    // æª¢æŸ¥é—œéµå­—åŒ¹é…
    if (!user.itemMatchesKeywords(tag, description)) {
      return false;
    }

    return true;
  }

  // æ–°å¢žï¼šç™¼é€é€šçŸ¥çµ¦ç”¨æˆ¶
  Future<void> _sendNotificationToUser({
    required UserModel user,
    required String itemId,
    required String itemTitle,
    required String itemDescription,
    required List<String> matchedKeywords,
    required double distance,
    String? imageUrl,
  }) async {
    try {
      // å‰µå»ºé€šçŸ¥è¨˜éŒ„
      NotificationModel notification = NotificationModel.newItemMatch(
        userId: user.uid,
        itemId: itemId,
        itemTitle: itemTitle,
        itemDescription: itemDescription,
        matchedKeywords: matchedKeywords,
        distanceKm: distance,
        imageUrl: imageUrl,
      );

      // ä¿å­˜é€šçŸ¥è¨˜éŒ„åˆ° Firestore
      await _firestore.collection('notifications').add(notification.toFirestore());

      // æ›´æ–°ç”¨æˆ¶çš„å·²é€šçŸ¥ç‰©å“åˆ—è¡¨
      UserModel updatedUser = user.markItemNotified(itemId);
      await _firestore.collection('users').doc(user.uid).update({
        'notifiedItemIds': updatedUser.notifiedItemIds,
      });

      print('ItemService: å·²é€šçŸ¥ç”¨æˆ¶ ${user.username}ï¼Œç¬¦åˆé—œéµå­—: ${matchedKeywords.join(', ')}');

    } catch (e) {
      print('ItemService: ç™¼é€é€šçŸ¥å¤±æ•—: $e');
    }
  }

  // æ–°å¢žï¼šè¨ˆç®—å…©é»žé–“è·é›¢ï¼ˆå…¬é‡Œï¼‰
  double _calculateDistance(double lat1, double lon1, double lat2, double lon2) {
    const double earthRadius = 6371; // åœ°çƒåŠå¾‘ï¼ˆå…¬é‡Œï¼‰
    
    double dLat = _toRadians(lat2 - lat1);
    double dLon = _toRadians(lon2 - lon1);
    
    double a = sin(dLat / 2) * sin(dLat / 2) +
        cos(_toRadians(lat1)) * cos(_toRadians(lat2)) *
        sin(dLon / 2) * sin(dLon / 2);
    
    double c = 2 * atan2(sqrt(a), sqrt(1 - a));
    
    return earthRadius * c;
  }

  double _toRadians(double degree) {
    return degree * (pi / 180);
  }

  // æ–°å¢žï¼šä½ç½®è®ŠåŒ–æ™‚æª¢æŸ¥é™„è¿‘ç‰©å“ï¼ˆä¾›å¤–éƒ¨èª¿ç”¨ï¼‰
  Future<void> checkLocationChangeNotifications(String userId, double newLat, double newLng) async {
    try {
      print('ItemService: æª¢æŸ¥ä½ç½®è®ŠåŒ–æŽ¨æ’­');
      
      // ç²å–ç”¨æˆ¶è³‡æ–™
      DocumentSnapshot userDoc = await _firestore.collection('users').doc(userId).get();
      if (!userDoc.exists) return;
      
      UserModel user = UserModel.fromFirestore(userDoc);
      if (!user.preferences.enableNotifications || !user.notificationSettings.locationUpdateNotifications) {
        return;
      }

      // ç²å–æ–°ä½ç½®é™„è¿‘çš„ç‰©å“
      List<ItemModel> nearbyItems = await getMapVisibleItems(newLat, newLng, 2.0);
      
      // æª¢æŸ¥æ¯å€‹ç‰©å“æ˜¯å¦ç¬¦åˆç”¨æˆ¶çš„é—œéµå­—ä¸”æœªé€šçŸ¥éŽ
      List<Future<void>> notificationTasks = [];
      
      for (ItemModel item in nearbyItems) {
        if (user.shouldReceiveNotification(item.id, item.location.latitude, item.location.longitude) &&
            user.itemMatchesKeywords(item.tag, item.description)) {
          
          List<String> matchedKeywords = user.getMatchedKeywords(item.tag, item.description);
          double distance = _calculateDistance(newLat, newLng, item.location.latitude, item.location.longitude);
          
          // å‰µå»ºä½ç½®æ›´æ–°é€šçŸ¥
          NotificationModel notification = NotificationModel.locationUpdate(
            userId: userId,
            itemId: item.id,
            itemTitle: item.tag,
            matchedKeywords: matchedKeywords,
            distanceKm: distance,
            imageUrl: item.imageUrls.isNotEmpty ? item.imageUrls.first : null,
          );
          
          // ç™¼é€é€šçŸ¥
          notificationTasks.add(_sendLocationUpdateNotification(user, notification));
        }
      }
      
      if (notificationTasks.isNotEmpty) {
        await Future.wait(notificationTasks);
        print('ItemService: ä½ç½®è®ŠåŒ–æŽ¨æ’­å®Œæˆï¼Œç™¼é€äº† ${notificationTasks.length} å€‹é€šçŸ¥');
      }
      
    } catch (e) {
      print('ItemService: ä½ç½®è®ŠåŒ–æŽ¨æ’­æª¢æŸ¥å¤±æ•—: $e');
    }
  }

  // æ–°å¢žï¼šç™¼é€ä½ç½®è®ŠåŒ–é€šçŸ¥
  Future<void> _sendLocationUpdateNotification(UserModel user, NotificationModel notification) async {
    try {
      // ä¿å­˜é€šçŸ¥è¨˜éŒ„
      await _firestore.collection('notifications').add(notification.toFirestore());

      // æ›´æ–°ç”¨æˆ¶å·²é€šçŸ¥åˆ—è¡¨
      UserModel updatedUser = user.markItemNotified(notification.itemId!);
      await _firestore.collection('users').doc(user.uid).update({
        'notifiedItemIds': updatedUser.notifiedItemIds,
      });

    } catch (e) {
      print('ItemService: ç™¼é€ä½ç½®è®ŠåŒ–é€šçŸ¥å¤±æ•—: $e');
    }
  }

  LocationData _addRandomOffset(LocationData originalLocation) {
    final random = Random();
    double latOffset = (random.nextDouble() - 0.5) * 2 * (0.2 / 111);
    double lonOffset = (random.nextDouble() - 0.5) * 2 * 
        (0.2 / (111 * cos(originalLocation.latitude * pi / 180)));
    
    return LocationData(
      latitude: originalLocation.latitude + latOffset,
      longitude: originalLocation.longitude + lonOffset,
      address: originalLocation.address,
    );
  }

  Future<List<String>> _uploadImages(String itemId, List<File> imageFiles) async {
    List<String> urls = [];
    
    for (int i = 0; i < imageFiles.length; i++) {
      try {
        String fileName = '${itemId}_$i.jpg';
        Reference ref = _storage.ref().child('items/$itemId/$fileName');
        
        UploadTask uploadTask = ref.putFile(
            imageFiles[i],
            SettableMetadata(
            contentType: 'image/jpeg',
            cacheControl: 'max-age=60',
          ),
        );
        TaskSnapshot snapshot = await uploadTask;
        String url = await snapshot.ref.getDownloadURL();
        urls.add(url);
      } catch (e) {
        print('_uploadImages: ç¬¬ ${i+1} å¼µåœ–ç‰‡ä¸Šå‚³å¤±æ•—: $e');
        throw e;
      }
    }
    
    return urls;
  }

  // ç²å–é™„è¿‘çš„ç‰©å“ - æ›´æ–°ç‚ºä½¿ç”¨æ–°çš„ç‹€æ…‹ç³»çµ±
  Future<List<ItemModel>> getNearbyItems(
      double latitude, double longitude, double radiusInKm) async {
    try {
      final currentUserId = _currentUserId;
      if (currentUserId == null) return [];

      GeoFirePoint center = _geo.point(latitude: latitude, longitude: longitude);
      
      Stream<List<DocumentSnapshot>> stream = _geo
          .collection(collectionRef: _firestore.collection('items'))
          .within(center: center, radius: radiusInKm, field: 'g');
      
      List<DocumentSnapshot> snapshots = await stream.first;
      
      List<ItemModel> items = snapshots
          .map((doc) => ItemModel.fromFirestore(doc))
          .where((item) => item.isVisibleToUser(currentUserId) && !item.isReported)
          .toList();
      return items;

    } catch (e) {
      print('Error getting nearby items: $e');
      return [];
    }
  }

  // ç²å–åœ°åœ–å¯é¡¯ç¤ºçš„ç‰©å“ï¼ˆåªæœ‰ä¸Šæž¶ç‹€æ…‹ä¸”æœªè¢«æª¢èˆ‰ï¼‰
  Future<List<ItemModel>> getMapVisibleItems(
      double latitude, double longitude, double radiusInKm) async {
    try {
      GeoFirePoint center = _geo.point(latitude: latitude, longitude: longitude);
      
      Stream<List<DocumentSnapshot>> stream = _geo
          .collection(collectionRef: _firestore.collection('items'))
          .within(center: center, radius: radiusInKm, field: 'g');
      
      List<DocumentSnapshot> snapshots = await stream.first;
      
      List<ItemModel> items = snapshots
          .map((doc) => ItemModel.fromFirestore(doc))
          .where((item) => 
            item.status == ItemStatus.available && 
            !item.isReported
          )
          .toList();
      return items;

    } catch (e) {
      print('Error getting map visible items: $e');
      return [];
    }
  }

  Future<ItemModel?> getItemById(String itemId) async {
    try {
      DocumentSnapshot doc = await _firestore
          .collection('items')
          .doc(itemId)
          .get();
      
      if (doc.exists) {
        return ItemModel.fromFirestore(doc);
      }
      return null;
    } catch (e) {
      print('Error getting item by ID: $e');
      return null;
    }
  }

  Future<List<ItemModel>> getUserItems(String userId) async {
    try {
      QuerySnapshot query = await _firestore
          .collection('items')
          .where('ownerId', isEqualTo: userId)
          .orderBy('createdAt', descending: true)
          .get();

      return query.docs.map((doc) => ItemModel.fromFirestore(doc)).toList();
    } catch (e) {
      print('Error getting user items: $e');
      return [];
    }
  }

  Future<List<ItemModel>> getItemsByTag(String tag, double latitude, 
      double longitude, double radiusInKm) async {
    try {
      List<ItemModel> nearbyItems = await getNearbyItems(latitude, longitude, radiusInKm);
      return nearbyItems.where((item) => item.tag == tag).toList();
    } catch (e) {
      print('Error getting items by tag: $e');
      return [];
    }
  }

  // æ›´æ–°ç‰©å“ç‹€æ…‹ - é‡æ§‹ç‚ºæ”¯æŒæ–°çš„ç‹€æ…‹ç³»çµ±
  Future<void> updateItemStatus(String itemId, ItemStatus status) async {
    await _firestore.collection('items').doc(itemId).update({
      'status': status.name,
    });
  }

  // ä¸Šæž¶ç‰©å“
  Future<void> putItemOnline(String itemId) async {
    try {
      await _firestore.collection('items').doc(itemId).update({
        'status': ItemStatus.available.name,
        'reservedByUserId': null,
        'reservedAt': null,
      });
    } catch (e) {
      print('Error putting item online: $e');
      throw e;
    }
  }

  // ä¸‹æž¶ç‰©å“
  Future<void> takeItemOffline(String itemId) async {
    try {
      await _firestore.collection('items').doc(itemId).update({
        'status': ItemStatus.offline.name,
        'reservedByUserId': null,
        'reservedAt': null,
      });
    } catch (e) {
      print('Error taking item offline: $e');
      throw e;
    }
  }

  // é ç´„ç‰©å“
  Future<void> reserveItem(String itemId, String reserverUserId) async {
    try {
      final now = DateTime.now();
      await _firestore.collection('items').doc(itemId).update({
        'status': ItemStatus.reserved.name,
        'reservedByUserId': reserverUserId,
        'reservedAt': Timestamp.fromDate(now),
      });
    } catch (e) {
      print('Error reserving item: $e');
      throw e;
    }
  }

  // æ¨™è¨˜äº¤æ˜“å®Œæˆ
  Future<void> markItemCompleted(String itemId) async {
    try {
      final now = DateTime.now();
      await _firestore.collection('items').doc(itemId).update({
        'status': ItemStatus.completed.name,
        'completedAt': Timestamp.fromDate(now),
      });
    } catch (e) {
      print('Error marking item as completed: $e');
      throw e;
    }
  }

  // æ›´æ–°è©•åƒ¹ç‹€æ…‹
  Future<void> updateRatingStatus(String itemId, bool isOwnerRating) async {
    try {
      final updateData = isOwnerRating 
          ? {'hasOwnerRated': true}
          : {'hasReserverRated': true};
      
      await _firestore.collection('items').doc(itemId).update(updateData);
    } catch (e) {
      print('Error updating rating status: $e');
      throw e;
    }
  }

  // ä¿ç•™åŽŸæœ‰çš„ updateItemAvailability ä½†æ¨™è¨˜ç‚ºå·²æ£„ç”¨
  @deprecated
  Future<void> updateItemAvailability(String itemId, bool isAvailable) async {
    // è½‰æ›ç‚ºæ–°çš„ç‹€æ…‹ç³»çµ±
    ItemStatus status = isAvailable ? ItemStatus.available : ItemStatus.offline;
    await updateItemStatus(itemId, status);
  }

  Future<void> updateItem({
    required String itemId,
    required String description,
    required String tag,
    required List<String> existingImageUrls,
    required List<File> newImageFiles,
  }) async {
    try {
      List<String> newImageUrls = [];
      if (newImageFiles.isNotEmpty) {
        newImageUrls = await _uploadImages(itemId, newImageFiles);
      }

      List<String> allImageUrls = [...existingImageUrls, ...newImageUrls];

      Map<String, dynamic> updates = {
        'description': description,
        'tag': tag,
        'imageUrls': allImageUrls,
      };

      await _firestore.collection('items').doc(itemId).update(updates);
    } catch (e) {
      print('Error updating item: $e');
      throw e;
    }
  }

  // åˆªé™¤ç‰©å“ - æ›´æ–°ç‚ºæ”¯æŒäº¤æ˜“è¨˜éŒ„ä¿å­˜
  Future<void> deleteItem(String itemId) async {
    try {
      DocumentSnapshot doc = await _firestore
          .collection('items')
          .doc(itemId)
          .get();
      
      if (doc.exists) {
        ItemModel item = ItemModel.fromFirestore(doc);
        
        // å¦‚æžœæ˜¯äº¤æ˜“å®Œæˆç‹€æ…‹ï¼Œå…ˆä¿å­˜äº¤æ˜“è¨˜éŒ„
        if (item.status == ItemStatus.completed) {
          await _saveTransactionRecord(item);
        }

        // åˆªé™¤åœ–ç‰‡
        for (String imageUrl in item.imageUrls) {
          try {
            await FirebaseStorage.instance.refFromURL(imageUrl).delete();
          } catch (e) {
            print('Error deleting image: $e');
          }
        }
        
        // åˆªé™¤ç‰©å“
        await _firestore.collection('items').doc(itemId).delete();
      }
    } catch (e) {
      print('Error deleting item: $e');
      throw e;
    }
  }

  // ä¿å­˜äº¤æ˜“è¨˜éŒ„
  Future<void> _saveTransactionRecord(ItemModel item) async {
    if (item.reservedByUserId == null) return;

    try {
      final transactionRecord = {
        'itemId': item.id,
        'itemDescription': item.description,
        'itemTag': item.tag,
        'itemImageUrls': item.imageUrls,
        'ownerId': item.ownerId,
        'reserverUserId': item.reservedByUserId,
        'transactionDate': item.completedAt ?? DateTime.now(),
        'createdAt': DateTime.now(),
      };

      await _firestore
          .collection(_transactionRecordsCollection)
          .add(transactionRecord);
    } catch (e) {
      print('Error saving transaction record: $e');
      throw e;
    }
  }

  // ç²å–ç”¨æˆ¶äº¤æ˜“è¨˜éŒ„
  Future<List<Map<String, dynamic>>> getUserTransactionRecords(String userId) async {
    try {
      // ç²å–ä½œç‚ºç‰©å“æ“æœ‰è€…çš„è¨˜éŒ„
      QuerySnapshot ownerQuery = await _firestore
          .collection(_transactionRecordsCollection)
          .where('ownerId', isEqualTo: userId)
          .orderBy('transactionDate', descending: true)
          .get();

      List<Map<String, dynamic>> ownerRecords = ownerQuery.docs.map((doc) {
        final data = doc.data() as Map<String, dynamic>;
        data['id'] = doc.id;
        data['userRole'] = 'owner';
        return data;
      }).toList();

      // ç²å–ä½œç‚ºé ç´„è€…çš„è¨˜éŒ„
      QuerySnapshot reserverQuery = await _firestore
          .collection(_transactionRecordsCollection)
          .where('reserverUserId', isEqualTo: userId)
          .orderBy('transactionDate', descending: true)
          .get();

      List<Map<String, dynamic>> reserverRecords = reserverQuery.docs.map((doc) {
        final data = doc.data() as Map<String, dynamic>;
        data['id'] = doc.id;
        data['userRole'] = 'reserver';
        return data;
      }).toList();

      // åˆä½µä¸¦æŒ‰æ—¥æœŸæŽ’åº
      List<Map<String, dynamic>> allRecords = [...ownerRecords, ...reserverRecords];
      allRecords.sort((a, b) {
        DateTime dateA = (a['transactionDate'] as Timestamp).toDate();
        DateTime dateB = (b['transactionDate'] as Timestamp).toDate();
        return dateB.compareTo(dateA);
      });

      return allRecords;
    } catch (e) {
      print('Error getting user transaction records: $e');
      return [];
    }
  }

  // æ›´æ–°ç”¨æˆ¶ç‰©å“çµ±è¨ˆ - æ”¯æŒæ–°çš„ç‹€æ…‹ç³»çµ±
  Future<Map<String, int>> getUserItemStats(String userId) async {
    try {
      QuerySnapshot query = await _firestore
          .collection('items')
          .where('ownerId', isEqualTo: userId)
          .get();

      Map<String, int> stats = {
        'total': 0,
        'available': 0,
        'offline': 0,
        'reserved': 0,
        'completed': 0,
        'reported': 0,
      };

      for (var doc in query.docs) {
        Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
        String status = data['status'] ?? 'available';
        bool isReported = data['isReported'] ?? false;

        stats['total'] = stats['total']! + 1;

        if (isReported) {
          stats['reported'] = stats['reported']! + 1;
        } else {
          stats[status] = (stats[status] ?? 0) + 1;
        }
      }

      return stats;
    } catch (e) {
      print('Error getting user item stats: $e');
      return {
        'total': 0,
        'available': 0,
        'offline': 0,
        'reserved': 0,
        'completed': 0,
        'reported': 0,
      };
    }
  }

  Future<void> reportItem(String itemId, String reporterId, String reason) async {
    await _firestore.collection('items').doc(itemId).update({
      'reportCount': FieldValue.increment(1),
      'isReported': true,
    });

    String reportId = Uuid().v4();
    await _firestore.collection('reports').doc(reportId).set({
      'id': reportId,
      'reporterId': reporterId,
      'targetType': 'item',
      'targetId': itemId,
      'reason': reason,
      'status': 'pending',
      'createdAt': Timestamp.now(),
    });
  }
}
